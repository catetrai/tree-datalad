#!/usr/bin/env bash

set -e


usage() {
    cat <<EOF

Usage: $(basename "$0") [-h] [TREE_OPTS ...]

Run 'tree' command and mark directories that are DataLad datasets.
Takes any options to be passed to 'tree'.

Options:
    [-h]                show help
    [TREE_OPTS ...]     options to be passed to tree command

EOF
} >&2

extract_path() {
    # extract file/directory path from line of 'tree' output
    echo "$1" |
        sed 's/\x1B\[[0-9;]\{1,\}[A-Za-z]//g' |  # strip color codes
        sed -E 's/ -> .*$//g' |  # strip resolved symlink
        sed -E 's/\/$//g' |  # strip directory suffix '/' (if tree -F)
        sed -E 's/( +[0-9]+ bytes? used in )?[0-9]+ director(y|ies), [0-9]+ files?//g' |  # strip report line
        sed -E 's/^.*[-─]{2} \[.*\]  (.*)$/\1/g' |  # for tree options with '[]' section
        sed -E 's/^.*[-─]{2} (.*)$/\1/g'  # for all other tree options
}

ds_marker() {
    # marker to append to the line of 'tree' output if it is a dataset
    echo '  <--[DS]'
}

run() {
    if [[ "$1" = '-h' ]]; then
        usage
        exit 0
    fi

    # check if 'tree' was called with option '-f' (to print full path)
    # note the quick'n'dirty parsing of single option
    has_full_path=false
    if echo "$@" | grep -qE '^-f| +-f|^-[^- ]+f| +-[^- ]+f'; then
        has_full_path=true
    fi

    # run 'tree' with '-f' option (print full paths)
    # and transform each line
    line_count=0
    tree -f "$@" |
    while IFS=$'\n' read -r line; do
        line_count=$((line_count+1))

        # extract file/directory path
        path="$(extract_path "$line")"

        # if there's no path (e.g. whitespace), just print raw tree output
        if ! [[ -e "$path" ]]; then
            echo "$line"
            continue
        fi

        # if is dataset, set the DS marker
        marker=''
        if [[ -f "$path"/.datalad/config ]]; then
            marker="$(ds_marker)"
        fi

        if $has_full_path || [[ $line_count = 1 ]]; then
            # The first line is always the path of input directory
            # (either full or relative, as it was specified in argument)
            echo "${line}${marker}"
        else
            # replace with the basename to revert the effect of '-f'
            path_basename="$(basename $path)"
            echo "${line//$path/$path_basename}${marker}"
        fi
    done
}

# If the script is being executed (not sourced), run main function
# If it is sourced, only export functions without running main
# see: https://stackoverflow.com/a/2942183
if [[ "$(basename "$0")" = "tree-datalad" ]]; then
    run "$@"
fi
